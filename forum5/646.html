<html xmlns:my="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link type="text/css" rel="stylesheet" href="../css/program-think.css">
</head>
<body>
<h1>Comments on 编程随想的博客: 架构设计：生产者/消费者模式[3]：环形缓冲区</h1>
<p><strong><font color="red">updated </font></strong>2009-04-08T15:47:00.000+08:00<br><strong><font color="red">content </font></strong>看来楼上的同学是老读者兼热心读者，经常发表一些评论，非常感谢 :)<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://4.bp.blogspot.com/_itipB8vBZzQ/SY1isusKAfI/AAAAAAAAAGo/4YF360m0Yto/S220/Thinker_BlogSpot.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-04-08T14:09:00.000+08:00<br><strong><font color="red">content </font></strong>多谢，看到这里，感觉到楼主在真心分享一些一线的经验。&lt;BR/&gt;环形缓冲区也类似一种模式，有其使用场景的限定的，这点楼主也说的很明白。而且，模式一般也会稍微脱离一下具体实现语言的限制。<br><strong><font color="red">author </font></strong>Kyle M. Lee<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://3.bp.blogspot.com/_b7FdT41py7w/SMFUQ-dI7wI/AAAAAAAACqo/YI2Hxxdpgm4/S220/kyle.xi.an.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-04-02T10:57:00.000+08:00<br><strong><font color="red">content </font></strong>另外，补充一下circular_buffer的介绍（摘自boost官方网站）：&lt;BR/&gt;The basic motivation behind the circular_buffer was to create a container which would work seamlessly with STL. Additionally, the design of the circular_buffer was guided by the following principles:&lt;BR/&gt;   1. Maximum efficiency for envisaged applications.&lt;BR/&gt;   2. Suitable for general purpose use.&lt;BR/&gt;   3. The behaviour of the buffer as intuitive as possible.&lt;BR/&gt;   4. Suitable for specialization by means of adaptors. (The circular_buffer_space_optimized is such an example of the adaptor.)&lt;BR/&gt;   5. Easy to debug. (See Debug Support for details.)&lt;BR/&gt;&lt;BR/&gt;In order to achieve maximum efficiency, the circular_buffer stores its elements in a contiguous region of memory, which then enables:&lt;BR/&gt;   1. Use of fixed memory and no implicit or unexpected memory allocation.&lt;BR/&gt;   2. Fast constant-time insertion and removal of elements from the front and back.&lt;BR/&gt;   3. Fast constant-time random access of elements.&lt;BR/&gt;   4. Suitability for real-time and performance critical applications.<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://4.bp.blogspot.com/_itipB8vBZzQ/SY1isusKAfI/AAAAAAAAAGo/4YF360m0Yto/S220/Thinker_BlogSpot.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-04-02T10:44:00.000+08:00<br><strong><font color="red">content </font></strong>楼上的同学，&lt;BR/&gt;allocator确实能够优化内存分配和释放。不过C++之外的语言，不一定有类似STL allocator的东东可用。这时候还是得考虑环形缓冲区。&lt;BR/&gt;另外，circular_buffer相比STL的容器还是有某些优势的（否则boost也不会加入这个玩意儿了:-）。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://4.bp.blogspot.com/_itipB8vBZzQ/SY1isusKAfI/AAAAAAAAAGo/4YF360m0Yto/S220/Thinker_BlogSpot.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-04-02T10:22:00.000+08:00<br><strong><font color="red">content </font></strong>在C++里面，STL中的容器默认使用STL提供的allocator实现来获取内存。至少在gcc的STL实现中，那东东就是个内存池，是只分配不释放的。而gcc中的deque实现，采用的是分段数组（不知道这玩意有没学名）的方式，也在很大程度上减少了队列长度增长时的重分配效应。而且这种方案没长度限制，在一定程度上。当然，还是要自个搞定并发的问题。<br><strong><font color="red">author </font></strong>GlacJAY<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2009-04-01T22:59:00.000+08:00<br><strong><font color="red">content </font></strong>楼上的同学，&lt;BR/&gt;就因为circbuf是GPL协议，所以我才说它不太爽。象它这种以“库”的形式提供的开源项目，通常都采用LGPL而不是GPL。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://4.bp.blogspot.com/_itipB8vBZzQ/SY1isusKAfI/AAAAAAAAAGo/4YF360m0Yto/S220/Thinker_BlogSpot.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-04-01T21:27:00.000+08:00<br><strong><font color="red">content </font></strong>circbuf发布的代码里附带的License是GPL<br><strong><font color="red">author </font></strong>Gzm's blog<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2009-04-01T12:09:00.000+08:00<br><strong><font color="red">content </font></strong>感谢楼上的同学提意见，我又补充说明了一下两者实现上的差别。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://4.bp.blogspot.com/_itipB8vBZzQ/SY1isusKAfI/AAAAAAAAAGo/4YF360m0Yto/S220/Thinker_BlogSpot.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-04-01T11:05:00.000+08:00<br><strong><font color="red">content </font></strong>博主没有讲清楚为什么环形缓冲区相对于队列缓冲区具有性能优势。<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/blank.gif</p>
</body>
</html>
