<html xmlns:my="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link type="text/css" rel="stylesheet" href="../css/program-think.css">
</head>
<body>
<h1>Comments on 编程随想的博客: Java 性能优化[2]：字符串过滤实战</h1>
<p><strong><font color="red">updated </font></strong>2016-06-27T15:04:10.896+08:00<br><strong><font color="red">content </font></strong>LZ不错，上马治国评天下，下马编程写程序，哈哈！！<br><strong><font color="red">author </font></strong>Tony Tan<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2014-12-25T18:26:21.533+08:00<br><strong><font color="red">content </font></strong>正则表达式也可以过滤么<br><strong><font color="red">author </font></strong>vsked<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2014-07-07T15:09:59.624+08:00<br><strong><font color="red">content </font></strong>java8 都出来了 这个系列还没有结束。。。。<br><strong><font color="red">author </font></strong>瘦肉丝<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2013-05-23T14:48:24.085+08:00<br><strong><font color="red">content </font></strong>俺猜测&lt;br /&gt;有可能在 JDK 1.7 里面，对 String.length() 的调用已经在编译时优化掉了。&lt;br /&gt;所以用局部变量先保存长度，没有提升。&lt;br /&gt;&lt;br /&gt;你的测试数据中，F32 和 F3 其实很接近（百分比的差异）&lt;br /&gt;说明在 JDK 1.7 里面，两种写法差异不大。&lt;br /&gt;&lt;br /&gt;另，&lt;br /&gt;对比当年俺用 JDk 1.5 的测试数据。&lt;br /&gt;看来 JDK 后续的版本在编译优化方面，有提升。&lt;br /&gt;<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://1.bp.blogspot.com/-AmZd_cbsMA8/Th5EbQ2_22I/AAAAAAAAAfg/loksvIqGzic/s220/Thinker.jpg</p>
<p><strong><font color="red">updated </font></strong>2013-05-21T11:53:54.890+08:00<br><strong><font color="red">content </font></strong>09年的帖啦，现在才看到，T..T,用jdk1.7.0小测了下，发现以上结论基本成立，除了filter3提升不明显，偶尔甚至比filter2还慢。于是，对filter3中的优化作了调整，如filter32：&lt;br /&gt;private static String filter32(String strOld)&lt;br /&gt;{  &lt;br /&gt;            StringBuffer strNew = new StringBuffer();&lt;br /&gt;     //int nLen = strOld.length();    &lt;br /&gt;     &lt;br /&gt;     for(int i=0; i&amp;lt;strOld.length(); i++)&lt;br /&gt;     {&lt;br /&gt;      &lt;br /&gt;        char ch = strOld.charAt(i);&lt;br /&gt;        if(&amp;#39;0&amp;#39;&amp;lt;=ch &amp;amp;&amp;amp; ch&amp;lt;=&amp;#39;9&amp;#39;)&lt;br /&gt;        {&lt;br /&gt;          strNew.append(ch);&lt;br /&gt;        }&lt;br /&gt;     }&lt;br /&gt;     return strNew.toString();&lt;br /&gt;   }&lt;br /&gt;测试结果显示，filter32明显优于filter2和filter3,怀疑是否因为filter3中重复创建局部变量int的时间开销已超出重复调用length()的时间开销，以至于吃力不讨好？ 或者是jdk1.7优化的其他原因&lt;br /&gt;&lt;br /&gt;测试结果示例：&lt;br /&gt;F2:1090-1099&lt;br /&gt;F3:1073-1084&lt;br /&gt;F32:1057-1066<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2012-12-30T10:41:13.327+08:00<br><strong><font color="red">content </font></strong>你可能没仔细看 版本3 和 版本4 的差异。&lt;br /&gt;&lt;br /&gt;版本4 相比 版本3，仅仅多了一个 StringBuffer 的构造函数参数。&lt;br /&gt;这样一来，版本4 的 StringBuffer 就会在构造时事先分配足够的内存。&lt;br /&gt;所以 版本4 在每次 append 的时候不会再重分配内存，也不会进行内存拷贝。&lt;br /&gt;&lt;br /&gt;你说的内存分配和内存拷贝导致的性能差异，是发生在 版本3 和 版本5 之间的。&lt;br /&gt;版本4 不存在此问题。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://1.bp.blogspot.com/-AmZd_cbsMA8/Th5EbQ2_22I/AAAAAAAAAfg/loksvIqGzic/s220/Thinker.jpg</p>
<p><strong><font color="red">updated </font></strong>2012-12-28T15:15:26.386+08:00<br><strong><font color="red">content </font></strong>关于第五个版本比第四个版本更快的主要原因，并不在于创建stringbuffer对象上（当然这个也是一个原因），更主要的在于第四个版本每次在append的时候，都会判定当前分配的char是否已经满了，如果满了，会重新new一个新的char数组，并进行一次内存的拷贝。经过测试，Stringbuffer（我用的stringbuilder）的创建消耗相对而言可以忽略~~<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2009-07-23T03:55:50.688+08:00<br><strong><font color="red">content </font></strong>Good article, but I still see the room for improvement:&lt;br /&gt;&lt;br /&gt;In版本5, change&lt;br /&gt; if(&amp;#39;0&amp;#39;&amp;lt;=ch &amp;amp;&amp;amp; ch&amp;lt;=&amp;#39;9&amp;#39;)  &lt;br /&gt;to&lt;br /&gt; if (! (ch &amp;gt;&amp;#39;9&amp;#39; || ch &amp;lt;&amp;#39;0&amp;#39;)) &lt;br /&gt;&lt;br /&gt;we may reduce total number of the loop and buy some time, partially when the size of original string is BIG!<br><strong><font color="red">author </font></strong>szuo<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2009-04-02T20:18:00.000+08:00<br><strong><font color="red">content </font></strong>如果排除了随机误差，你试试看用Java反编译器对两个class文件处理一下，看反编译出来的源代码有什么差别？<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://4.bp.blogspot.com/_itipB8vBZzQ/SY1isusKAfI/AAAAAAAAAGo/4YF360m0Yto/S220/Thinker_BlogSpot.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-04-02T19:27:00.000+08:00<br><strong><font color="red">content </font></strong>下面是测试记录，单位：毫秒&lt;BR/&gt;filter_1()执行次数为：10 * 1024 * 1024&lt;BR/&gt;加了判断：  5187, 5203, 5172, 5188, 5235&lt;BR/&gt;没有加判断：5625, 5719, 5703, 5672, 5687&lt;BR/&gt;感觉虽然对结果的影响非常小，还是有影响的...&lt;BR/&gt;困惑的是，从直觉上来讲，少了一次判断，应该更快才对，可是测试结果却跟直觉相反<br><strong><font color="red">author </font></strong>渔夫<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://2.bp.blogspot.com/_BU0qLYlS0SQ/SbN1Fqh2kiI/AAAAAAAABA4/I2nHan1vid4/S220/p111407488.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-04-02T15:15:00.000+08:00<br><strong><font color="red">content </font></strong>楼上的同学，&lt;BR/&gt;感觉加了这个判断，应该对结果影响非常小。&lt;BR/&gt;“快了几十毫秒”会不会是随机误差？你多测试几次看看。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://4.bp.blogspot.com/_itipB8vBZzQ/SY1isusKAfI/AAAAAAAAAGo/4YF360m0Yto/S220/Thinker_BlogSpot.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-04-02T14:41:00.000+08:00<br><strong><font color="red">content </font></strong>补充，我的两个filter是在jdk6.5下面做的&lt;BR/&gt;&lt;BR/&gt;还有我惊奇的发现，我的filter2加了下面这个判断后，反而快了几十毫秒，不知为何。&lt;BR/&gt;if (input == null) {&lt;BR/&gt;return "";&lt;BR/&gt;}<br><strong><font color="red">author </font></strong>渔夫<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://2.bp.blogspot.com/_BU0qLYlS0SQ/SbN1Fqh2kiI/AAAAAAAABA4/I2nHan1vid4/S220/p111407488.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-04-02T14:39:00.000+08:00<br><strong><font color="red">content </font></strong>这是我第一次写的:&lt;BR/&gt;public static String filter_0(String input) {&lt;BR/&gt;  if (input == null) {&lt;BR/&gt;   return &amp;quot;&amp;quot;;&lt;BR/&gt;  }&lt;BR/&gt;  StringBuffer out_buffer = new StringBuffer();&lt;BR/&gt;  char[] input_chars = input.toCharArray();&lt;BR/&gt;  for (int i = 0; i &amp;lt; input_chars.length; i ++) {&lt;BR/&gt;   if (input_chars[i] &amp;gt;= 48 &amp;amp;&amp;amp; input_chars[i] &amp;lt; 58) {&lt;BR/&gt;    out_buffer.append(input_chars[i]);&lt;BR/&gt;   }&lt;BR/&gt;  }&lt;BR/&gt;  &lt;BR/&gt;  return out_buffer.toString();&lt;BR/&gt; }&lt;BR/&gt;输出为：&lt;BR/&gt;1125 (大概为1.125秒)&lt;BR/&gt;1867833672165189614000&lt;BR/&gt;经过你的提示，这是我优化后的：&lt;BR/&gt;public static String filter_1(String input) {  &lt;BR/&gt;  if (input == null) {&lt;BR/&gt;   return &amp;quot;&amp;quot;;&lt;BR/&gt;  }&lt;BR/&gt;  char[] chars = input.toCharArray();&lt;BR/&gt;  int pos = 0;&lt;BR/&gt;  for (int i = 0; i &amp;lt; chars.length; i ++) {&lt;BR/&gt;   if (chars[i] &amp;gt;= 48 &amp;amp;&amp;amp; chars[i] &amp;lt; 58) {&lt;BR/&gt;    chars[pos++] = chars[i];&lt;BR/&gt;   }&lt;BR/&gt;  }&lt;BR/&gt;  &lt;BR/&gt;  return new String(chars, 0, pos);&lt;BR/&gt; }&lt;BR/&gt;输出为：&lt;BR/&gt;531 大概为0.531秒&lt;BR/&gt;1867833672165189614000<br><strong><font color="red">author </font></strong>渔夫<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://2.bp.blogspot.com/_BU0qLYlS0SQ/SbN1Fqh2kiI/AAAAAAAABA4/I2nHan1vid4/S220/p111407488.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-03-27T13:36:00.000+08:00<br><strong><font color="red">content </font></strong>我像前辈们学习啊<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2009-03-25T13:09:00.000+08:00<br><strong><font color="red">content </font></strong>原来JAVA代码也可以如此优化 优化效果也这么明显 赞LZ ^_^<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2009-03-23T11:51:00.000+08:00<br><strong><font color="red">content </font></strong>楼上的同学，&lt;BR/&gt;这个例子只要是用来说明内存分配对性能的影响。不过实际工作中也会碰到类似的例子，比如过滤掉字符串中的某些字符。如果对性能比较敏感，用正则不一定合适。假如被过滤的不是字符串，而是非char类型的某种集合，那正则可能也帮不上忙。&lt;BR/&gt;另外，不知道你所说的“一百万次的差别在100毫秒”，是指哪两个版本之间的对比？<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://4.bp.blogspot.com/_itipB8vBZzQ/SY1isusKAfI/AAAAAAAAAGo/4YF360m0Yto/S220/Thinker_BlogSpot.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-03-23T11:12:00.000+08:00<br><strong><font color="red">content </font></strong>从字符串提出所有数字的需求是怎个上下文呢?&lt;BR/&gt;在我的机器上一百万次的差别在100毫秒, 我想这算不上什么优化.&lt;BR/&gt;如果是为了提出连续的数字, 我宁愿用/[0-9]+/.test(string)这么简单的做法.<br><strong><font color="red">author </font></strong>Rex Sheng<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://shengning.googlepages.com/rex.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-03-21T16:29:00.000+08:00<br><strong><font color="red">content </font></strong>非常非常的好谢谢！！！！！！！！！！！<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2009-03-21T10:42:00.000+08:00<br><strong><font color="red">content </font></strong>楼上的同学，&lt;BR/&gt;看来某些情况下，有可能同步开销造成的差异大于内存分配的差异，我在原文中补充说明一下。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://4.bp.blogspot.com/_itipB8vBZzQ/SY1isusKAfI/AAAAAAAAAGo/4YF360m0Yto/S220/Thinker_BlogSpot.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-03-21T09:11:00.000+08:00<br><strong><font color="red">content </font></strong>不同机器、不同版本之间的差异比较明显：我用JBuilder2006下的JDK1.5进行了测试：filter4用时还是2.5秒，改为StringBuilder后耗时0.95秒，filter5用时0.67秒。从生成的字节码也看出不同版本生成的字节码也有不同。<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2009-03-21T08:54:00.000+08:00<br><strong><font color="red">content </font></strong>我是用JDK1.6测试的：&lt;BR/&gt;filter4用时大约2.5秒，将其中的StringBuffer改成StringBuilder以后用时0.67秒，filter5用时大约0.46秒。&lt;BR/&gt;我的机器是双核的，可能不同的机器不同的版本都有较大的区别 从我的测试结果看，感觉是同步开销使得filter4差别那么大的。&lt;BR/&gt;楼主这篇文章对优化有很好的引导作用，十分感谢。<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2009-03-20T17:23:00.000+08:00<br><strong><font color="red">content </font></strong>楼上的同学，&lt;BR/&gt;我在相同的环境下，把filter4改用StringBuilder，测试了一下，大概耗时1.15-1.20秒。性能相比StringBuffer约提升了0.2秒。&lt;BR/&gt;而使用数组的filter5大概耗时0.72-0.78秒，比StringBuilder提升了约0.4秒。数组和StringBuilder之间的差异主要是由内存分配造成。&lt;BR/&gt;所以，同步开销带来的性能影响（0.2秒）应该不如内存分配带来的影响（0.4秒）。&lt;BR/&gt;不过JDK 1.6或许会不一样。我有空的话用JDK 1.6再测试一下。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://4.bp.blogspot.com/_itipB8vBZzQ/SY1isusKAfI/AAAAAAAAAGo/4YF360m0Yto/S220/Thinker_BlogSpot.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-03-20T13:58:00.000+08:00<br><strong><font color="red">content </font></strong>“那是什么原因捏？&lt;BR/&gt;　　虽然filter5有一个字符数组的创建开销，但是相对于filter4来说，StringBuffer的构造函数内部也会有字符数组的创建开销。两相抵消。所以filter5比filter4还多节省了StringBuffer对象本省的创建开销。所以节约了性能。”&lt;BR/&gt;感觉上面这一条并不正确，filter4与filter5性能差别的主要原因应该是filter4方法中StringBuffer同步开销很大所致。<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2009-03-20T12:08:00.000+08:00<br><strong><font color="red">content </font></strong>StringBuilder确实比StringBuffer快，当初考虑到会在不同版本间做对比测试，所以还是用StringBuffer。它们两者在内存分配上是类似的，性能的差别主要在于线程安全方面。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://4.bp.blogspot.com/_itipB8vBZzQ/SY1isusKAfI/AAAAAAAAAGo/4YF360m0Yto/S220/Thinker_BlogSpot.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-03-20T11:36:00.000+08:00<br><strong><font color="red">content </font></strong>测试了下，换成了StringBuilder后，时间减少了一半，但是还是比直接用char数组稍慢<br><strong><font color="red">author </font></strong>dennis<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2009-03-20T11:30:00.000+08:00<br><strong><font color="red">content </font></strong>StringBuffer可以替换成StringBuilder,StringBuffer多了个同步开销。<br><strong><font color="red">author </font></strong>dennis<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2009-03-20T11:11:00.000+08:00<br><strong><font color="red">content </font></strong>楼上的同学，&lt;BR/&gt;估计是JDK 1.6作了优化，而JDK 1.5没有做。&lt;BR/&gt;不过版本2和版本3之间的差异不是本文讨论的重点，所以我没有再深入探讨。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://4.bp.blogspot.com/_itipB8vBZzQ/SY1isusKAfI/AAAAAAAAAGo/4YF360m0Yto/S220/Thinker_BlogSpot.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-03-20T11:02:00.000+08:00<br><strong><font color="red">content </font></strong>按理说filter2到filter3的优化是编译技术中最基本的优化，一般编译器都会做的啊（或者JVM）。我机器上是jdk1.6，试了一下，filter3的测试结果要比2慢几十毫秒。&lt;BR/&gt;&lt;BR/&gt;另外如果不需要考虑线程安全的话，使用StringBuilder替换StringBuffer的版本倒是可以将执行时间缩短到 1/3<br><strong><font color="red">author </font></strong>qingbo<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2009-03-19T21:04:00.000+08:00<br><strong><font color="red">content </font></strong>很好很强大，俺先看了1，还自己写了例子，才来看2的。<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2009-03-19T16:49:00.000+08:00<br><strong><font color="red">content </font></strong>:-)还是依然感谢楼主这么无私的一直写的如此勤快，很有帮组，还特别感谢在我困惑时对我的建议<br><strong><font color="red">author </font></strong>身<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2009-03-19T16:46:00.000+08:00<br><strong><font color="red">content </font></strong>楼上的同学，&lt;BR/&gt;这个问题问得好。这正是我后面的帖子打算讨论的话题 :-)&lt;BR/&gt;我先简单提一下：String result = "hello" + " world";并不是真正的字符串拼接，实际上编译时就已经变成"hello world"。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://4.bp.blogspot.com/_itipB8vBZzQ/SY1isusKAfI/AAAAAAAAAGo/4YF360m0Yto/S220/Thinker_BlogSpot.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-03-19T16:35:00.000+08:00<br><strong><font color="red">content </font></strong>(1) String result = "hello" + " world";&lt;BR/&gt;(2) StringBuffer result = new String().append("hello").append(" world");&lt;BR/&gt;楼主觉得这两个哪个效率高呢？<br><strong><font color="red">author </font></strong>身<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2009-03-19T14:05:00.000+08:00<br><strong><font color="red">content </font></strong>楼上的同学，&lt;BR/&gt;其实length()开销不大。如果不是对性能很敏感，直接写在for里面，问题也不大。&lt;BR/&gt;另外，感谢你的夸奖，“全能”不敢当。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://4.bp.blogspot.com/_itipB8vBZzQ/SY1isusKAfI/AAAAAAAAAGo/4YF360m0Yto/S220/Thinker_BlogSpot.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-03-19T13:37:00.000+08:00<br><strong><font color="red">content </font></strong>"另外把strOld.length()先保存为nLen，也节省了重复调用length()的开销。"&lt;BR/&gt;好像编译器会优化捏？不过还是不能太依赖 是不 O(∩_∩)O&lt;BR/&gt;lz 好像很全能 管理 设计 编程<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2009-03-19T13:00:00.000+08:00<br><strong><font color="red">content </font></strong>orz<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2009-03-19T09:39:00.000+08:00<br><strong><font color="red">content </font></strong>写得不错，看过后有收获呢&lt;BR/&gt;继续关注后边的文章<br><strong><font color="red">author </font></strong>schlolar.luo<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/blank.gif</p>
</body>
</html>
