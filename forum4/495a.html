<html xmlns:my="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link type="text/css" rel="stylesheet" href="../css/program-think.css">
</head>
<body>
<h1>Comments on 编程随想的博客: 求质数算法的 N 种境界[1] - 试除法和初级筛法</h1>
<p><strong><font color="red">updated </font></strong>2020-01-10T20:24:16.214+08:00<br><strong><font color="red">content </font></strong>文章里的简单筛法确实会重复过滤，比如30。当然有其它线性的筛法。另外，啥时候出下篇呀<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2019-10-19T07:12:37.422+08:00<br><strong><font color="red">content </font></strong>@3單元&lt;br /&gt;思考了五分鐘，成功得出答案，果然是奧妙之一。<br><strong><font color="red">author </font></strong>網友000<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2019-05-10T11:17:49.283+08:00<br><strong><font color="red">content </font></strong>知识无价，寻求最优解是好的。<br><strong><font color="red">author </font></strong>@许还真<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>//1.bp.blogspot.com/-RaoEbCgk-No/XNJ6cgaG_QI/AAAAAAAAAeg/wlEKmVRQWKAYyAx5S81gnyAI62RSKWWiACK4BGAYYCw/s220/29e65c679df14c81a42096a08eba0c85.png</p>
<p><strong><font color="red">updated </font></strong>2019-03-31T10:17:50.948+08:00<br><strong><font color="red">content </font></strong>这些思想如果不是大牛研究出来，您可以自己研究出来吗?<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2019-03-29T19:42:21.089+08:00<br><strong><font color="red">content </font></strong>在软件编程层面越过编译器差异论底层在现实中遇到的可能性不高吧？初级的不会有那么深入的了解；高级的这样的问题有些太大了，不如直截了当问了<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2018-07-10T13:32:26.086+08:00<br><strong><font color="red">content </font></strong>2018年的知乎live&lt;br /&gt;求质数表的n种境界&lt;br /&gt;https://www.zhihu.com/lives/951407164133216256&lt;br /&gt;https://www.zhihu.com/lives/951407442270138368<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2018-07-10T13:24:09.483+08:00<br><strong><font color="red">content </font></strong>此评论已被作者删除。<br><strong><font color="red">author </font></strong>-科技无意义<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>//lh5.googleusercontent.com/-52uIzM_4Lns/AAAAAAAAAAI/AAAAAAAAAcM/3SJKSpfD_BI/s512-c/photo.jpg</p>
<p><strong><font color="red">updated </font></strong>2018-03-04T10:50:23.274+08:00<br><strong><font color="red">content </font></strong>又又又又又又找到太监了。<br><strong><font color="red">author </font></strong>Mr. Cui Keng<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2018-03-04T10:47:36.328+08:00<br><strong><font color="red">content </font></strong>再次找到太监。&lt;br /&gt;<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2017-09-15T17:00:06.548+08:00<br><strong><font color="red">content </font></strong>其实并不需要求范围。比如先求1000以内的质数，不够再求1000-2000的质数，并和前面的合并，质数也可以结合前面的结果来筛选。如此可以一直迭代下去，也不用一下分配很大的内存。<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2016-01-17T22:42:59.172+08:00<br><strong><font color="red">content </font></strong>小学时就看过埃拉托斯特尼素数筛，然而到现在仍然不怎么懂编程。<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2015-08-29T15:02:06.389+08:00<br><strong><font color="red">content </font></strong>不錯不錯，學習了。我還不知道我的小伙伴們只不知掉篩法呢……嘿嘿。<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2015-07-31T15:57:05.093+08:00<br><strong><font color="red">content </font></strong>你依然可以使用筛法计算出一定范围内的质数，如果不够，再用试除法去解决剩余的质数。<br><strong><font color="red">author </font></strong>没头像的<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2015-07-30T16:10:33.456+08:00<br><strong><font color="red">content </font></strong>啥时候出下一篇呐？<br><strong><font color="red">author </font></strong>Major Zhu<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>//lh5.googleusercontent.com/-W6viKif-MaM/AAAAAAAAAAI/AAAAAAAAABI/tRq1DUwIIWc/s512-c/photo.jpg</p>
<p><strong><font color="red">updated </font></strong>2015-04-28T13:05:03.730+08:00<br><strong><font color="red">content </font></strong>4/5用vector push_back 和预先定义差不了多少&lt;br /&gt;&lt;br /&gt;inline int si(int n){&lt;br /&gt;  int L= 1.5*n/log(double(n));&lt;br /&gt;  return   floor(double(L)) ;&lt;br /&gt; }&lt;br /&gt; &lt;br /&gt; int countPrimes2(long n){&lt;br /&gt;  if (n &amp;lt;2 ) return 0;&lt;br /&gt;        if (n == 2) return 1;&lt;br /&gt;  if (n&amp;lt;=2) return 0;&lt;br /&gt;        int M=si(n);&lt;br /&gt;        M = (M&amp;gt;1000)?M:200;&lt;br /&gt;  int * iL = new int[M];&lt;br /&gt;&lt;br /&gt;  int s;&lt;br /&gt;  int i;&lt;br /&gt;  int L = 1;&lt;br /&gt;  iL[0]=2;&lt;br /&gt;  for (i =3; i&amp;lt;=n; i++){&lt;br /&gt;  s=0;  &lt;br /&gt;  for (int j =0; (j &amp;lt; L) &amp;amp; (iL[j]*iL[j] &amp;lt;= n) ;j++){ &lt;br /&gt;    if (i%iL[j]==0)s++;&lt;br /&gt;   }&lt;br /&gt;  &lt;br /&gt;  if (s==0) {  iL[L]=i;L++;}&lt;br /&gt;  }&lt;br /&gt;  delete[] iL;&lt;br /&gt;  return L;&lt;br /&gt; }&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;思路1/2其实尾递归形式上很漂亮，但是低效：&lt;br /&gt;&lt;br /&gt; long countPrimes(long n, long a){&lt;br /&gt;        long isp = 1;&lt;br /&gt;        if (n%2 == 0) {&lt;br /&gt;            isp=0;&lt;br /&gt;        }else{&lt;br /&gt;            for (long i=1;i&amp;lt;(n/2)-1;i++) {&lt;br /&gt;            if ( n%(2*i+1) == 0) {&lt;br /&gt;    isp=0;&lt;br /&gt;    break;&lt;br /&gt;   }&lt;br /&gt;        }    &lt;br /&gt;        }&lt;br /&gt;  return (n==2)?a:countPrimes(n-1,a+isp);&lt;br /&gt; }&lt;br /&gt;    long countPrimes(long n) {&lt;br /&gt;     if (n &amp;lt;2 ) return 0;&lt;br /&gt;        if (n == 2) return 1;&lt;br /&gt;        return countPrimes(n,1);&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;不用筛法很难达到O(n loglog n)....&lt;br /&gt;&lt;br /&gt;<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2015-04-23T13:59:44.918+08:00<br><strong><font color="red">content </font></strong>仔细看了楼主的思路，怎么找不到后续的了？有后续境界吗？<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2014-07-09T01:17:26.731+08:00<br><strong><font color="red">content </font></strong>呵呵 张益唐已经证明了质数不是越到后来越稀疏&lt;br /&gt;&lt;br /&gt;这是个重大突破&lt;br /&gt;&lt;br /&gt;<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2014-02-04T23:00:04.114+08:00<br><strong><font color="red">content </font></strong>TO 2单元的网友&lt;br /&gt;多谢发表不同观点 :)&lt;br /&gt;看问题要抓“主要矛盾”。&lt;br /&gt;乘法和除法之间的性能差异不是主要矛盾。&lt;br /&gt;主要矛盾是“筛法”的运算总次数远远小于“试除法”（尤其是相对于“试除法”的前3种境界）。&lt;br /&gt;换句话说：&lt;br /&gt;乘法相对于除法导致的性能提升，应该占小头；而运算总次数的显著下降才是性能提升的大头。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://1.bp.blogspot.com/-AmZd_cbsMA8/Th5EbQ2_22I/AAAAAAAAAfg/loksvIqGzic/s220/Thinker.jpg</p>
<p><strong><font color="red">updated </font></strong>2014-01-14T00:48:38.602+08:00<br><strong><font color="red">content </font></strong>看看Intel的优化手册就知道32位/64位的整数乘法和整数除法之间的差异是很大的。<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2013-06-24T17:03:13.645+08:00<br><strong><font color="red">content </font></strong>囧<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2013-06-03T13:42:18.797+08:00<br><strong><font color="red">content </font></strong>俺觉得：&lt;br /&gt;CPU 对乘法和除法的性能差异，可以忽略不计。&lt;br /&gt;两者的主要差异在于，“筛法”的运算总次数更少（尤其是相对于“试除法”的前3种境界）。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://1.bp.blogspot.com/-AmZd_cbsMA8/Th5EbQ2_22I/AAAAAAAAAfg/loksvIqGzic/s220/Thinker.jpg</p>
<p><strong><font color="red">updated </font></strong>2013-05-31T15:22:36.564+08:00<br><strong><font color="red">content </font></strong>怎么都没人说cpu算乘法比除法快？&lt;br /&gt;这才是第二种方法真正的优势吧<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2013-04-23T21:05:33.910+08:00<br><strong><font color="red">content </font></strong>山外有山、天外有天。每一个技术领域里面的每一个细小的分支，深究下去都有很多的门道与奥妙。在你深究的过程中，必然会学到很多东西。深究的过程也就是你能力提高的过程。&lt;br /&gt;&lt;br /&gt;记下了<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2013-04-16T22:53:58.601+08:00<br><strong><font color="red">content </font></strong>近期忙着写政治、心理学、网络安全。&lt;br /&gt;看了一下本文的发布日期，没想到已经过去一年了！&lt;br /&gt;也不知道啥时候能抽空把本文的后续写完 :(<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://1.bp.blogspot.com/-AmZd_cbsMA8/Th5EbQ2_22I/AAAAAAAAAfg/loksvIqGzic/s220/Thinker.jpg</p>
<p><strong><font color="red">updated </font></strong>2013-04-13T00:31:17.911+08:00<br><strong><font color="red">content </font></strong>博主你的后续还没出来啊.. 等着看精彩的呢<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2013-03-09T18:22:40.300+08:00<br><strong><font color="red">content </font></strong>在正确的筛法中，6 并不会被重复过滤两次。&lt;br /&gt;请仔细看动画，或者看看俺在 5楼3单元 的留言<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://1.bp.blogspot.com/-AmZd_cbsMA8/Th5EbQ2_22I/AAAAAAAAAfg/loksvIqGzic/s220/Thinker.jpg</p>
<p><strong><font color="red">updated </font></strong>2013-03-09T18:20:18.694+08:00<br><strong><font color="red">content </font></strong>TO 2单元的同学&lt;br /&gt;看来你真的没理解筛法的奥妙之一。&lt;br /&gt;&lt;br /&gt;当筛除 3 的倍数时，直接从 9 开始。&lt;br /&gt;当筛除 5 的倍数时，直接从 25 开始。&lt;br /&gt;为啥是这样？请自己思考一下。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://1.bp.blogspot.com/-AmZd_cbsMA8/Th5EbQ2_22I/AAAAAAAAAfg/loksvIqGzic/s220/Thinker.jpg</p>
<p><strong><font color="red">updated </font></strong>2013-03-07T09:31:31.210+08:00<br><strong><font color="red">content </font></strong>关于3楼的问题和博主的答复&lt;br /&gt;动画中6没有被染绿色应该是动画本身的bug，12不是由红变绿了吗？&lt;br /&gt;对于筛法来说，重复过滤往往难以避免。<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2013-02-21T07:45:29.937+08:00<br><strong><font color="red">content </font></strong>我觉得前四楼是一个人<br><strong><font color="red">author </font></strong>yz q<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>//lh5.googleusercontent.com/-Y9cx46uSAqE/AAAAAAAAAAI/AAAAAAAABWk/ASsimfzeQ24/s512-c/photo.jpg</p>
<p><strong><font color="red">updated </font></strong>2013-02-21T07:44:04.773+08:00<br><strong><font color="red">content </font></strong>显然是你记错了，1 byte，自己看&lt;br /&gt;http://msdn.microsoft.com/en-us/library/tf4dy80a.aspx<br><strong><font color="red">author </font></strong>yz q<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>//lh5.googleusercontent.com/-Y9cx46uSAqE/AAAAAAAAAAI/AAAAAAAABWk/ASsimfzeQ24/s512-c/photo.jpg</p>
<p><strong><font color="red">updated </font></strong>2013-01-20T22:07:34.903+08:00<br><strong><font color="red">content </font></strong>我之前的回复确实没有把限定条件说明白。素数无穷小学生都知道，小学数学里有一节是介绍的用计算机求得迄今为止的最大素数，也不时有计算最大质素的新闻。我把我之前话再重复一遍“素数分布式越来越稀，那么某一范围内的素数的总个数范围有限，根据干法，存储一个既有的素数表得了，判断是不是素数可以直接按表查找，大素数可以单独讨论”。&lt;br /&gt;不知道你是怎么判断我基础差的，你记得欧几里得干过什么就能证明基础不差了？“我猜想”三个字完全是出于对这篇没有写完的文章的敬意，没有动手比较过各种算法的保留。我也拜托，匿名有意思么&lt;br /&gt;再者，这么干我不是第一个，《c++编程艺术》里面有说这个的，无可厚非。质素表确实可以用来加快求质素的过程，随便google了一下真有这么干的。<br><strong><font color="red">author </font></strong>limian<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2013-01-20T19:11:40.401+08:00<br><strong><font color="red">content </font></strong>基础差露馅就不要狡辩了。&lt;br /&gt;再抓个逻辑问题，人家讨论求质数的算法，这就是既定目的。你却要先来个质数表。<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2013-01-20T10:32:18.381+08:00<br><strong><font color="red">content </font></strong>提高原子操作的效率是一方面，但是有蚂蚁算法这样的另类，就不能说一味的提高原子操作的效率就可以了。处理复杂性，就应该充分利用计算机的性能，比如有限元求解，针对复杂边界条件，只要把问题网格化就能得到近似的结果。我猜想这个质素题目的最高境界里面一定有一个阶段是面对一个超巨量的需求，将需求化整为零，各个击破，用不着什么这原理那原理。   我曾经求过一个圆形散粒体（多尺度）在限定的边界内随机分布的问题，要求圆不相交，且要求出分布的最大密度。这是我理解的处理复杂的艺术<br><strong><font color="red">author </font></strong>limian<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2013-01-20T10:17:42.556+08:00<br><strong><font color="red">content </font></strong>类似于与先把结果先算出来的把戏，其实应用还是蛮多的。提高效率，首先要提高完成单个目标的效率，然后减少完成多个目标之间的重复，还要将任务适当的排序，或者并发。后者不是复杂度什么的吗 <br><strong><font color="red">author </font></strong>limian<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2013-01-20T10:04:10.376+08:00<br><strong><font color="red">content </font></strong>需求是有限的，这里又不是搞数学研究，我上面的话不严谨。而且计算机本是就是有限的，只要达成既定目的就行<br><strong><font color="red">author </font></strong>limian<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2013-01-20T01:00:32.732+08:00<br><strong><font color="red">content </font></strong>拜托，公元前300年的欧几里德已经证明素数无穷<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2013-01-19T20:52:30.774+08:00<br><strong><font color="red">content </font></strong>我猜想素数分布式越来越稀，那么素数的总个数范围有限，根据干法，存储一个既有的素数表得了，判断是不是素数可以直接按表查找。<br><strong><font color="red">author </font></strong>limian<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2013-01-08T16:31:01.023+08:00<br><strong><font color="red">content </font></strong>确实有很多数学知识会遗忘，所以俺才挑选了小学数学的“质数和整除”，这个是不太可能忘掉的。&lt;br /&gt;&lt;br /&gt;另外，这道题考察了非常基本的算法思想——[b]用空间换时间[/b]&lt;br /&gt;虽然实际工作中不太可能碰到“求质数”，但是，实际工作中碰到的很多性能优化问题，都是用的“[b]用空间换时间[/b]”的思想。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://1.bp.blogspot.com/-AmZd_cbsMA8/Th5EbQ2_22I/AAAAAAAAAfg/loksvIqGzic/s220/Thinker.jpg</p>
<p><strong><font color="red">updated </font></strong>2013-01-06T14:18:52.041+08:00<br><strong><font color="red">content </font></strong>这道面试题似乎是在挑选ACM人才。公司的程序员在实际编程中，碰到这种问题的可能性几乎为零。而且工作经验越久，平时不用的数学知识忘得越多。<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2012-10-14T23:55:23.950+08:00<br><strong><font color="red">content </font></strong>关于是否看过答案，可分为4类：&lt;br /&gt;1、原本就会，没看过答案&lt;br /&gt;2、原本就会，看过答案&lt;br /&gt;3、原本不会，没看过答案&lt;br /&gt;4、原本不会，看过答案&lt;br /&gt;只有第4类人是有争议的。&lt;br /&gt;&lt;br /&gt;任何一种面试题，其实都难以做到完美。&lt;br /&gt;出题的人也需要与时俱进，不断想出新的花样，尽量减低第4类人的比例。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://1.bp.blogspot.com/-AmZd_cbsMA8/Th5EbQ2_22I/AAAAAAAAAfg/loksvIqGzic/s220/Thinker.jpg</p>
<p><strong><font color="red">updated </font></strong>2012-10-13T23:12:36.012+08:00<br><strong><font color="red">content </font></strong>我只是想说，一个看过答案和没看过答案的能力相差多少？<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2012-08-29T23:28:42.037+08:00<br><strong><font color="red">content </font></strong>C++初学者路过。。。我竟然直接想到了试除法境界5！（正在做project euler problem3）<br><strong><font color="red">author </font></strong>Dennis<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2012-05-22T21:05:17.736+08:00<br><strong><font color="red">content </font></strong>牛人就是多，一辈子也达不到这个高度了。。。<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2012-04-05T12:29:25.764+08:00<br><strong><font color="red">content </font></strong>去年看这个帖子，没有弄懂，现在才勉强看懂一些，原来一个看似简单的算法，包含着这么多层境界。&lt;br /&gt;初学Python，我第一次想到的也是试除法，其他的暂时都没想明白。<br><strong><font color="red">author </font></strong>记忆め碎片<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2012-01-06T00:05:07.508+08:00<br><strong><font color="red">content </font></strong>to gengyu89&lt;br /&gt;你这次的留言显然比前一次要有价值，表扬一下 :)&lt;br /&gt;&lt;br /&gt;关于“AKS素数判定法”&lt;br /&gt;你所说的“效率最高的算法”，应该就是指“AKS素数判定法”吧？&lt;br /&gt;据说2002年的那个版本，已经不是最牛的啦。&lt;br /&gt;2005年，另2个牛人搞出了该算法的变体，运算次数降为O((logn)^6)，且不再依赖于Sophie Germain质数的分布（也就是你说的素数密度猜想）&lt;br /&gt;俺顺手把论文链接找来了：&lt;br /&gt;http://www.math.dartmouth.edu/~carlp/aks041411.pdf&lt;br /&gt;http://www.math.dartmouth.edu/~carlp/PDF/complexity12.pdf&lt;br /&gt;&lt;br /&gt;顺便补充一下，AKS的牛逼之处在于它是第一个同时满足如下4条的素数判定法：&lt;br /&gt;1、通用性&lt;br /&gt;2、多项式时间&lt;br /&gt;3、确定性的&lt;br /&gt;4、不依赖未证明的猜想&lt;br /&gt;&lt;br /&gt;关于“确定性检验”和“概率检验”&lt;br /&gt;如果严格按照题意，显然不能用概率检验法。&lt;br /&gt;不过话说回来，假如某个应聘者能用概率检验法解答此题（虽然不能算完全答对），但这样的应聘者，能力会胜过仅仅用试除法且完全答对的人。&lt;br /&gt;这也就是俺在《通过笔试答题能看出啥》一文中着重强调的：&amp;quot;思路和想法&amp;quot;远远比&amp;quot;对错&amp;quot;更重要。&lt;br /&gt;&lt;br /&gt;关于“ln”和“log”的写法&lt;br /&gt;首先声明，俺不是数学专业出身，至今也没有看过一本正规的数论教材。估计大部分程序员也没看过。而 Windows 的计算器，大部分程序员是用过滴。它上面用 ln 表示自然对数。&lt;br /&gt;所以，ln 这个写法，对程序员读者来说，应该比较容易理解。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://1.bp.blogspot.com/-AmZd_cbsMA8/Th5EbQ2_22I/AAAAAAAAAfg/loksvIqGzic/s220/Thinker.jpg</p>
<p><strong><font color="red">updated </font></strong>2012-01-04T19:58:31.967+08:00<br><strong><font color="red">content </font></strong>在此我也要指出几点：&lt;br /&gt;1.文章中提出的素性检验都是确定性算法，即对于一个自然数是否素数给出确定的结论。目前效率最高的是2002年一个印度计算机教授M.Agrawal和他的两个本科生宣布的，对于整数n只要使用O((logn)^12)次位运算。在假定素数密度猜想成立的条件下，还可以改进到只要O((logn)^6)次位运算。&lt;br /&gt;2.除确定性算法外还有概率素性检验法，这种方法能知道一个自然数是否有很高的可能性是素数，但不确定到底是否素数。这种算法在素性检验有关的程序中是有很重要的应用的！&lt;br /&gt;3.为了要找出前N个素数，你在这里提到的是通过素数定理来估算需要在多大的范围内进行筛选。事实上还有另一种思路，为了要找出前N个素数，就需要知道第N个素数有多大。素数定理的推论给出了估算第N个素数大小的近似表达式：令Pn是第n个素数，其中n是正整数，那么Pn~nlogn&lt;br /&gt;注：素数密度猜想：p是素数，那么2p+1也是素数&lt;br /&gt;另注：在所有的数论书中都是用log表示自然对数而不是ln，这与其它地方不同&lt;br /&gt;我可以用LISP语言实现，不过你说的存储容器的问题，我对Java这种语言不熟，所以不太清楚这个概念&lt;br /&gt;当然，既然你说这只是个开头，离最高境界还早着了，我倒是期待你会出一篇更高层次的文章<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2011-12-22T16:25:12.203+08:00<br><strong><font color="red">content </font></strong>to 楼上的同学：&lt;br /&gt;听你的口气，貌似数学功底不错嘛。&lt;br /&gt;但是，千万不要以为这道题仅仅是考“算法”或者是考“数学”。&lt;br /&gt;这道题考察的知识面可广呢！&lt;br /&gt;&lt;br /&gt;你提到说：&lt;br /&gt;“对于一个学过离散数学和解析数论的数理专业学生来说，直接达到最高境界是很自然的事情。”&lt;br /&gt;&lt;br /&gt;俺要提醒一下：&lt;br /&gt;本文仅仅是一个开头，离最高境界还早着呢 :)&lt;br /&gt;有兴趣的话，可以看俺后续的内容。&lt;br /&gt;&lt;br /&gt;再提醒一下：&lt;br /&gt;不论是哪个学术领域，都是山外有山、天外有天。不可轻言“最高境界”。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://1.bp.blogspot.com/-AmZd_cbsMA8/Th5EbQ2_22I/AAAAAAAAAfg/loksvIqGzic/s220/Thinker.jpg</p>
<p><strong><font color="red">updated </font></strong>2011-12-22T04:14:12.281+08:00<br><strong><font color="red">content </font></strong>弱爆了，没有任何新意的思想或观点，完全给那些没有专门学过算法的编程初学者看的。这种涉及初等算法的题目作为计算机等级考试来考本科生还可以，怎么能作为面试题呢？对于一个学过离散数学和解析数论的数理专业学生来说，直接达到最高境界是很自然的事情。算法均来源于数学理论，而数学家是在研究数学，程序员只是在应用数学，因此搞程序的人玩数学永远玩不过数学家。<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2011-12-07T15:51:47.986+08:00<br><strong><font color="red">content </font></strong>在不考虑偏差的情况下，相当于解如下的方程&lt;br /&gt;x / ln(x) = N&lt;br /&gt;解出来的 x 就是你要用的最大范围 MAX&lt;br /&gt;考虑上偏差的话，再对 MAX 乘以 1.15&lt;br /&gt;-------------------------------------------&lt;br /&gt;这是超越方程，好像不太好解呀。&lt;br /&gt;wiki上面说素数定理可以给出第n个素数p（n）的渐近估计：&lt;br /&gt;p(n)~n*ln(n)&lt;br /&gt;不知道是怎么来的。而且不知道这个系数是多少。&lt;br /&gt;把x=n*ln(n)代到方程里面去就成了&lt;br /&gt;n*ln（n)/ln(n*ln(x))=n,好像是说ln(ln(x))可以忽略？<br><strong><font color="red">author </font></strong>阿成<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2011-12-06T15:40:27.553+08:00<br><strong><font color="red">content </font></strong>to 前三楼的评论者：&lt;br /&gt;俺在前面的帖子《通过笔试答疑能看出啥？》有介绍过：笔试阶段是为了淘汰掉80%的人。因此，俺不是根据笔试答题来判断谁更合适。笔试题目只是为了淘汰掉某些人。&lt;br /&gt;&lt;br /&gt;当然，再完美的笔试题目，也有可能发生少数的误判，导致好的人反而被淘汰掉。&lt;br /&gt;&lt;br /&gt;以这道题目为例，确实可能有某个优秀的应聘者用了C语言写了试除法，但是却连境界4和境界5都没有考虑到。并因此没能进入面试阶段。&lt;br /&gt;但是俺个人觉得：这样的概率应该挺小的。&lt;br /&gt;优秀的开发人员，应该比较容易想到（境界4和境界5）的其中之一。&lt;br /&gt;&lt;br /&gt;再来说说你举的4个例子。&lt;br /&gt;说实在的，俺碰到的面试者，平均素质都不是很高。（很有可能是因为俺公司不是知名的牛B公司，优秀的人看不上）&lt;br /&gt;大部分人都只是用常见的语言（比如C/C++/Java）实现了试除法的前3种境界之一。&lt;br /&gt;在这种情况下，如果某个应聘者能用 Lisp 答出此题；或者某个应聘者能够体现出筛法的idea；或者某个应聘者能够写出试除法的后两种境界之一。&lt;br /&gt;那么，俺通常都会让他们进入面试阶段。&lt;br /&gt;&lt;br /&gt;至于你提到的命名、注释等代码层面的问题，俺同样很看重。&lt;br /&gt;关于这点，俺在《通过笔试答疑能看出啥？》一文已经说了。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://1.bp.blogspot.com/-AmZd_cbsMA8/Th5EbQ2_22I/AAAAAAAAAfg/loksvIqGzic/s220/Thinker.jpg</p>
<p><strong><font color="red">updated </font></strong>2011-12-06T15:33:07.920+08:00<br><strong><font color="red">content </font></strong>to 阿成：&lt;br /&gt;在不考虑偏差的情况下，相当于解如下的方程&lt;br /&gt;x / ln(x) = N&lt;br /&gt;解出来的 x 就是你要用的最大范围 MAX&lt;br /&gt;考虑上偏差的话，再对 MAX 乘以 1.15<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://1.bp.blogspot.com/-AmZd_cbsMA8/Th5EbQ2_22I/AAAAAAAAAfg/loksvIqGzic/s220/Thinker.jpg</p>
<p><strong><font color="red">updated </font></strong>2011-12-06T14:43:10.670+08:00<br><strong><font color="red">content </font></strong>此评论已被作者删除。<br><strong><font color="red">author </font></strong>Will<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2011-12-06T08:47:44.633+08:00<br><strong><font color="red">content </font></strong>在ch ina ，一个政治家胜于千千万万名科学家<br><strong><font color="red">author </font></strong>march_seven<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2011-12-06T08:33:43.121+08:00<br><strong><font color="red">content </font></strong>你说的素数定理是不是说用&lt;br /&gt;#define MAX N*log(N)*1.15就可以表示最大范围呢？<br><strong><font color="red">author </font></strong>阿成<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2011-12-06T08:27:11.631+08:00<br><strong><font color="red">content </font></strong>#include&lt;br /&gt;using namespace std;&lt;br /&gt;#define N 10000&lt;br /&gt;int main()&lt;br /&gt;{&lt;br /&gt;    bool bNum[N];&lt;br /&gt;    int i,k; &lt;br /&gt;    for(i=0;i&amp;lt;N;i++) bNum[i]=true;&lt;br /&gt;    for(i=0;i&amp;lt;N;i++)&lt;br /&gt;    {&lt;br /&gt;     if(bNum[i])&lt;br /&gt;        {&lt;br /&gt;        for(k=2;((i+2)*k)&amp;lt;N+2;k++)&lt;br /&gt;            bNum[(i+2)*k-2]=false;&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;    for(i=0;i&amp;lt;N;i++)&lt;br /&gt;    {&lt;br /&gt;     if(bNum[i])&lt;br /&gt;        {&lt;br /&gt;        cout&amp;lt;&amp;lt;&amp;quot;The prime numbers less than N are: &amp;quot;&amp;lt;&amp;lt;i+2&amp;lt;&amp;lt;endl;&lt;br /&gt;        }&lt;br /&gt;     else continue;&lt;br /&gt;    }&lt;br /&gt;    return 0;&lt;br /&gt;}<br><strong><font color="red">author </font></strong>阿成<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2011-12-06T08:24:06.953+08:00<br><strong><font color="red">content </font></strong>此评论已被作者删除。<br><strong><font color="red">author </font></strong>阿成<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2011-12-05T11:33:40.537+08:00<br><strong><font color="red">content </font></strong>0.如果A用了试除法达到境界5，并写出了代码，B就写了“筛法”; 那你觉得A强还是B强？你更需要哪个？&lt;br /&gt;&lt;br /&gt;1.如果C和D用同一种算法，并实现了代码，D用C语言实现的，无递归；C用Lisp实现的，用了尾递归；D的速度肯定比C的快，但C的代码比D的短好几倍；你觉得哪个更强？&lt;br /&gt;&lt;br /&gt;如果单单从算法角度，达到境界4和5根本不算强，这和知识面有关，有些人知道筛法，有些人知道Miller-Rabin，有些人知道Sieve of Atkin，但是知道不代表其整体能力就强，不代表实现出来的代码就漂亮，这里面有多处权衡，很难因为算法上的一些trick而评出境界。&lt;br /&gt;&lt;br /&gt;我觉得，有时候面试者看重的是一个人的审美观，这些东西大多数时候只能从代码里面看出来。比如怎样尽量减少内存跳跃访问，怎样减少不必要的IO，怎样命名函数和变量，怎样写注释，怎样设计接口，怎样避免undefined行为，对内存模型的理解和运用等。&lt;br /&gt;&lt;br /&gt;当然，如果要上机，这个操作上有难度了。&lt;br /&gt;&lt;br /&gt;但有一点我持不同意见的：这里的境界的评定是有失偏颇的，一个有经验的不知道筛法的程序员看看wiki就能立马实现出一个漂亮的算法出来，但是看到你的考卷的时候他可能真的只能写出试除法，并且没有达到境界5.<br><strong><font color="red">author </font></strong>前三楼的评论者<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2011-12-04T20:28:29.067+08:00<br><strong><font color="red">content </font></strong>to 楼上的网友&lt;br /&gt;介绍N种境界，自然要由浅入深，方可体现出条理性。如果一上来就张口闭口“数论”，岂不是要吓到一片？&lt;br /&gt;本文才刚讲到“筛法”的开头，不要着急。&lt;br /&gt;再说了，数论并非考察软件开发人员的重点。俺不想反客为主。&lt;br /&gt;&lt;br /&gt;to 前2楼的网友&lt;br /&gt;请问哪个回复需要俺点评？&lt;br /&gt;&lt;br /&gt;to 前3楼的网友&lt;br /&gt;感谢写了这么长的回复。&lt;br /&gt;俺出的笔试题，确实没有明确给出一些限制条件（比如：性能的要求、对环境的要求）。&lt;br /&gt;俺是这样考虑的：&lt;br /&gt;如果某个应聘者在没有强调性能的情况下，依然写出性能尽量好的代码，这足以说明此人的能力和习惯。&lt;br /&gt;反之，如果某个应聘者能力很强，本来可以写出筛法，但是因为题目没要求，导致此人仅仅写出试除法。这也没有太大关系。&lt;br /&gt;因为一个能力强的人，即使用试除法，也能同时考虑境界4和境界5。这样的话，多半是能够通过笔试这关。到了面试的时候，俺就会针对性地提一些问题，其能力自然就能见分晓。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://1.bp.blogspot.com/-AmZd_cbsMA8/Th5EbQ2_22I/AAAAAAAAAfg/loksvIqGzic/s220/Thinker.jpg</p>
<p><strong><font color="red">updated </font></strong>2011-12-04T20:15:51.379+08:00<br><strong><font color="red">content </font></strong>哈哈，N种境界还，好好学学数论不吧，费马小定理都不知道就不要在这扯淡了<br><strong><font color="red">author </font></strong>123456<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2011-12-04T12:39:04.386+08:00<br><strong><font color="red">content </font></strong>楼主给点评一下:&lt;br /&gt;实现打印:&lt;br /&gt;http://blog.csdn.net/program_think/article/details/7032600#reply<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2011-12-03T21:35:21.807+08:00<br><strong><font color="red">content </font></strong>0. 整型对吧，有符号，32位，最大2147483647，最快的方式--查表。但这也是最耗内存的，但这取决于实际情况。&lt;br /&gt;1. 没有那么多资源，要尽量快？首先，你可能需要一个好的算法，这样的算法网上定能找到相应的参考，但是大多数人都不能手写出来，你可以手写出来么？所以，你说的算法上的境界，只是自娱自乐而已，你给台联网的电脑，你出这个题目试一试？&lt;br /&gt;2. 如果你说，求素数实在是瓶颈了，你又不能拿出那么多内存来，好的方法可能还是查表，不过要按照现实中出现N的范围分段查，这样平均复杂度也会低很多，如果N超出了范围，你再用找到的最好的算法去多出来的那一段。一般来说应该存那些较大的素数。&lt;br /&gt;3.如果觉得直接存指数到表里面浪费内存，那你可以用bit来代表一位数，比如，1Byte可以表示8位以内的素数，2Bit可以表示16位以内的素数，你还是觉得耗内存，好吧，内存太紧张了，又想最快，又不知道用在什么环境下，能把2～N分段计算么？支持多线程么？&lt;br /&gt;4.产生N这个源的分布是什么？如果就计算一次（或者几次）N，而且不知道大小，也不准有look up table. 只能现算，好吧！你出了一个ACM问题。如果要平凡的计算这样的N，是不是可以考虑cache？&lt;br /&gt;5. 幸好你说明了N是整型，不用考虑大整数，否则又是一个问题了。&lt;br /&gt;&lt;br /&gt;我想说的是，这种面试题只是简单的给出了问题，你没有构造出一个确切的需求，然后期待面试者按照你意淫出来的境界一层一层的给你惊喜，你后面又说，只要面试者的idea体现出来了就行，不用给出正确解。大家都是受了好多年应试教育的，你读书答证明题的时候随便写&amp;quot;此处通过质数分布公式推算范围&amp;quot;，老师会给你分么？你有这么勇敢过么？你在题目中交代，“只要写出思路也行”的提示么？&lt;br /&gt;我觉得，你真不如把这个题目分成如下两个问答题：&lt;br /&gt;&lt;br /&gt;0. 请问你知道求素数有那些最快的方法?（可自己分情况给出答案）&lt;br /&gt;1. 假如现在有大量的整型数需要缓存，有什么好的方法减少内存占用？&lt;br /&gt;&lt;br /&gt;我觉得面试也是被面试，没必要搞得那么装逼。<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2011-12-03T11:39:09.723+08:00<br><strong><font color="red">content </font></strong>个人觉得这题对于搞ACM的人来说实在是小菜一碟了  = =&lt;br /&gt;筛数法是数论最基本的题目之一，相比斐波那契数列的N多变种简单多了。。。就更不要说涉及图论，高精度，搜索，动规，以及各种坑爹的树了。。。囧&lt;br /&gt;当然，LZ很好的利用了这条经典题目~&lt;br /&gt;数据结构与算法分析，什么时候都是基础中的基础啊&lt;br /&gt;都说大公司笔试考的就是算法，果然不假。可惜，周围大部分的人对算法并不重视。一心就想着搞可视化编程，做UI。。。<br><strong><font color="red">author </font></strong>shanks<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2011-12-02T21:10:33.831+08:00<br><strong><font color="red">content </font></strong>第一反应Miller-Rabin...<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2011-12-02T18:30:06.780+08:00<br><strong><font color="red">content </font></strong>。。这搞得跟考OI一样了啊。。<br><strong><font color="red">author </font></strong>Junglerubik<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/b16-rounded.gif</p>
<p><strong><font color="red">updated </font></strong>2011-12-02T11:10:13.790+08:00<br><strong><font color="red">content </font></strong>对于程序员来说，掌握试除法和基本筛法就够了。&lt;br /&gt;验证质数，可参考wiki上的质数条目，写得比较全，不过对数学功底的要求较高。&lt;br /&gt;对于一些特定形式的质数，有快速验证算法的，还有分布式计算项目是算特定形式的质数的，如梅森素数，PrimeGrid等。&lt;br /&gt;&lt;br /&gt;本人参加PrimeGrid，找到过几个大质数，曾经是TOP 5000质数里的，可是被后来算出更大质数的挤出5000以外了 ：（<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2011-12-02T10:01:22.020+08:00<br><strong><font color="red">content </font></strong>to 2楼的同学：&lt;br /&gt;恰恰是因为 N 是不确定的，才更加能看出一个程序猿的水平。&lt;br /&gt;另外，能够想到筛法的同学，即便用试除法，通常也能够同时做到境界4和境界5。这样的人通常是有机会进入面试阶段的。&lt;br /&gt;而在面试阶段，俺就会拿这个题目试探应聘者。俺会问：在不同的硬件环境中，当N较大时，该如何处理？&lt;br /&gt;&lt;br /&gt;to 3楼的同学：&lt;br /&gt;当你认为6会被重复过滤两次时，就已经暴露出你并没有深刻领会筛法的奥妙。请仔细看动画。&lt;br /&gt;&lt;br /&gt;to 4楼的同学：&lt;br /&gt;你应该记错了。&lt;br /&gt;大部分C++编译器都把 sizeof(bool)实现为1，虽然C++标准没有显式规定。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://1.bp.blogspot.com/-AmZd_cbsMA8/Th5EbQ2_22I/AAAAAAAAAfg/loksvIqGzic/s220/Thinker.jpg</p>
<p><strong><font color="red">updated </font></strong>2011-12-02T08:46:15.464+08:00<br><strong><font color="red">content </font></strong>如果我没记错的话，C++的bool应该是4bytes<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2011-12-02T04:12:08.652+08:00<br><strong><font color="red">content </font></strong>筛法并不优越：&lt;br /&gt;1. 除法变乘法而已，效率并没提高（次数并没减少），相反，增加了运算，比如6，试除时，除以2即被否决（一次除法），筛法中，会被2、3的倍数重复地过滤（两次乘法）。&lt;br /&gt;2. 空间浪费，不现实。<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2011-12-02T02:31:47.154+08:00<br><strong><font color="red">content </font></strong>这题如果在考试的时候没有给出N的大小，筛法并不能说比普通方法优越，不过是空间换时间和时间换空间，题目中又没有说看重速度。如果是我答这个题很可能在知道筛法的情况下依然选用普通方法，因为我不知道有多大内存。<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2011-12-02T01:25:32.257+08:00<br><strong><font color="red">content </font></strong>2012电影里，美国总统对那年轻的科学家说；一个科学家胜过100个政治家。<br><strong><font color="red">author </font></strong>Anonymous<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>https://img1.blogblog.com/img/blank.gif</p>
</body>
</html>
