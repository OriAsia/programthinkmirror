<html xmlns:my="http://www.w3.org/2005/Atom" xmlns:gd="http://schemas.google.com/g/2005">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link type="text/css" rel="stylesheet" href="../css/program-think.css">
</head>
<body>
<h1>Comments on 编程随想的博客: C++ 对象是怎么死的？Win32 线程篇</h1>
<p><strong><font color="red">updated </font></strong>2009-03-19T10:30:00.000+08:00<br><strong><font color="red">content </font></strong>楼上的同学，&lt;BR/&gt;如果你先看了“C++对象是怎么死的？为什么要写这个系列？”，可能就不会误解了 :-)<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://4.bp.blogspot.com/_itipB8vBZzQ/SY1isusKAfI/AAAAAAAAAGo/4YF360m0Yto/S220/Thinker_BlogSpot.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-03-18T17:49:00.000+08:00<br><strong><font color="red">content </font></strong>我看那张表的第一印象就是，宿主线程结束后，宿主线程函数内的静态对象是能够析构的（因为表里面局部静态对象对应的表项为“能”），否则我也不会去做那个测试了，呵呵，或许是我没仔细看文章吧。<br><strong><font color="red">author </font></strong>Ordie<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2009-03-18T13:47:00.000+08:00<br><strong><font color="red">content </font></strong>当初考虑到局部静态对象是在线程中构造的，所以在测试是否析构的时候，把局部静态对象也一起验证了一下。&lt;BR/&gt;虽然测试结果表明：局部静态对象的析构是和线程的死亡没有太大关系。不过把它继续列在对照表中，也便于读者看出两者之间没有必然关系。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://4.bp.blogspot.com/_itipB8vBZzQ/SY1isusKAfI/AAAAAAAAAGo/4YF360m0Yto/S220/Thinker_BlogSpot.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-03-18T12:58:00.000+08:00<br><strong><font color="red">content </font></strong>既然是这样，那局部静态对象的析构 和 对象是由哪个线程创建 就没有什么因果关系了（只和进程有关），我觉得不应该列在上面那个表里。<br><strong><font color="red">author </font></strong>Ordie<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/blank.gif</p>
<p><strong><font color="red">updated </font></strong>2009-03-17T21:06:00.000+08:00<br><strong><font color="red">content </font></strong>局部静态对象的析构和非局部对象的析构类似，都要在进程自然死亡的时候，在main结束之后调用。<br><strong><font color="red">author </font></strong>编程随想<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://4.bp.blogspot.com/_itipB8vBZzQ/SY1isusKAfI/AAAAAAAAAGo/4YF360m0Yto/S220/Thinker_BlogSpot.jpg</p>
<p><strong><font color="red">updated </font></strong>2009-03-17T19:06:00.000+08:00<br><strong><font color="red">content </font></strong>局部静态对象的析构是不是也要等到主线程退出？我在Win32下做了个测试，即使是宿主线程所调用的函数内部的静态变量，在宿主线程退出时，析构函数并不会被调用，仍然要等到主线程退出。<br><strong><font color="red">author </font></strong>Ordie<br><strong><font color="red">uri </font></strong>html<br><strong><font color="red">avatar </font></strong>http://img1.blogblog.com/img/blank.gif</p>
</body>
</html>
